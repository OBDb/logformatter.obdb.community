<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log Parser</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            gap: 20px;
            flex: 1;
            min-height: 0;
        }
        
        .column {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        textarea { 
            flex: 1;
            width: 100%;
            margin: 10px 0;
            resize: none;
        }
        
        .input-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .file-upload {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .file-upload input[type="file"] {
            max-width: 200px;
        }
        
        h2 {
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="column">
            <h2>Paste Log Data</h2>
            <div class="input-controls">
                <div class="file-upload">
                    <input type="file" id="fileInput" accept=".txt,.log">
                </div>
            </div>
            <textarea id="inputLog" placeholder="Paste your log here or use the file upload above..."></textarea>
        </div>
        <div class="column">
            <h2>Extracted Data</h2>
            <textarea id="outputLog" readonly></textarea>
        </div>
    </div>
    <script>
        const inputLog = document.getElementById('inputLog');
        const fileInput = document.getElementById('fileInput');
        
        // Handle file upload
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    const text = await file.text();
                    inputLog.value = text;
                    processLog();
                } catch (err) {
                    console.error('Error reading file:', err);
                    alert('Error reading file. Please try again.');
                }
            }
        });

        // Handle paste and input events
        inputLog.addEventListener('input', () => {
            processLog();
        });

        function getCommandType(command) {
            const baseCommand = command.replace(/[0-9A-Fa-f]+(?:OFF|ON|SV[0-9A-Fa-f]+)?$/, '');
            return baseCommand;
        }

        function normalizeCommand(originalCommand) {
            command = originalCommand.substring(1);
            
            if (command.startsWith('01')) {
                return '>' + command.substring(0, 4);
            } else if (command.startsWith('09')) {
                return '>' + command.substring(0, 4);
            } else if (command.startsWith('21')) {
                return '>' + command.substring(0, 4);
            } else if (command.startsWith('22')) {
                return '>' + command.substring(0, 6);
            }
            return originalCommand;
        }

        function processLog() {
            const inputText = document.getElementById("inputLog").value;
            const lines = inputText.split(/\r?\n/);
            const vinGroups = new Map(); // Map<VIN, Map<commandKey, commandResponsePairs[]>>
            let currentVIN = "";
            let currentCommand = "";
            let currentResponses = [];
            let atCommands = new Map();
            let commandResponses = new Map(); // Map<commandKey, commandResponsePairs[]>
            
            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                
                if (/^(?:0[19]|21|22)[0-9A-F]{2,4}$/i.test(line)) return;
                
                if (line.startsWith('>')) {
                    if (currentCommand && !currentCommand.startsWith('>AT')) {
                        if (currentVIN) {
                            const latestATCommands = [...atCommands.values()]
                                .filter(cmd => !cmd.includes('ATRV'))
                                .sort();
                            const normalizedCommand = normalizeCommand(currentCommand);
                            const commandKey = `${latestATCommands.join(' ')}\n${normalizedCommand}`.trim();
                            const responseGroup = [...currentResponses];
                            
                            if (!commandResponses.has(commandKey)) {
                                commandResponses.set(commandKey, []);
                            }
                            
                            const commandResponsePair = {
                                originalCommand: currentCommand,
                                responses: responseGroup
                            };
                            
                            const existingGroups = commandResponses.get(commandKey);
                            if (!existingGroups.some(group => 
                                group.responses.length === responseGroup.length && 
                                group.responses.every((resp, idx) => resp === responseGroup[idx])
                            )) {
                                existingGroups.push(commandResponsePair);
                            }
                        }
                    }
                    
                    if (line.startsWith('>AT')) {
                        const atCommand = line.substring(1);
                        const commandType = getCommandType(atCommand);
                        atCommands.set(commandType, line);
                    } else {
                        if (line === '>0902') {
                            // Starting a new VIN section, let's commit all of the current responses to the current vin.
                            if (currentVIN) {
                                if (!vinGroups.has(currentVIN)) {
                                    vinGroups.set(currentVIN, new Map());
                                }
                                const vinCommands = vinGroups.get(currentVIN);
                                // Merge commandResponses with vinCommands, adding commandResponsesPairs to existing commandKeys if they already exist, or adding them if not.
                                for (const [commandKey, commandResponsePairs] of commandResponses.entries()) {
                                    const existingGroups = vinCommands.get(commandKey);
                                    if (existingGroups) {
                                        for (const commandResponsePair of commandResponsePairs) {
                                            if (!existingGroups.some(group => 
                                                group.responses.length === commandResponsePair.responses.length && 
                                                group.responses.every((resp, idx) => resp === commandResponsePair.responses[idx])
                                            )) {
                                                existingGroups.push(commandResponsePair);
                                            }
                                        }
                                    } else {
                                        vinCommands.set(commandKey, commandResponsePairs);
                                    }
                                }
                            }
                            currentVIN = "";
                            commandResponses = new Map(); // Map<commandKey, commandResponsePairs[]>
                        }
                        currentCommand = line;
                        currentResponses = [];
                    }
                } else {
                    currentResponses.push(line);
                    if (currentCommand === '>0902') {
                        currentVIN += (currentVIN ? '\n' : '') + line;
                    }
                }
            });
            
            if (currentCommand && !currentCommand.startsWith('>AT')) {
                if (currentVIN) {
                    const latestATCommands = [...atCommands.values()]
                        .filter(cmd => !cmd.includes('ATRV'))
                        .sort();
                    const normalizedCommand = normalizeCommand(currentCommand);
                    const commandKey = `${latestATCommands.join(' ')}\n${normalizedCommand}`.trim();
                    const responseGroup = [...currentResponses];
                    
                    if (!commandResponses.has(commandKey)) {
                        commandResponses.set(commandKey, []);
                    }
                    
                    const commandResponsePair = {
                        originalCommand: currentCommand,
                        responses: responseGroup
                    };
                    
                    const existingGroups = commandResponses.get(commandKey);
                    if (!existingGroups.some(group => 
                        group.responses.length === responseGroup.length && 
                        group.responses.every((resp, idx) => resp === responseGroup[idx])
                    )) {
                        existingGroups.push(commandResponsePair);
                    }
                }
            }

            if (currentVIN) {
                if (!vinGroups.has(currentVIN)) {
                    vinGroups.set(currentVIN, new Map());
                }
                const vinCommands = vinGroups.get(currentVIN);
                // Merge commandResponses with vinCommands, adding commandResponsesPairs to existing commandKeys if they already exist, or adding them if not.
                for (const [commandKey, commandResponsePairs] of commandResponses.entries()) {
                    const existingGroups = vinCommands.get(commandKey);
                    if (existingGroups) {
                        for (const commandResponsePair of commandResponsePairs) {
                            if (!existingGroups.some(group => 
                                group.responses.length === commandResponsePair.responses.length && 
                                group.responses.every((resp, idx) => resp === commandResponsePair.responses[idx])
                            )) {
                                existingGroups.push(commandResponsePair);
                            }
                        }
                    } else {
                        vinCommands.set(commandKey, commandResponsePairs);
                    }
                }
            }

            let output = '';
            // For each vin in vinGroups:
            for (const [vin, commands] of vinGroups.entries()) {
                output += '\n\n>0902\n' + vin + '\n\n';

                [...commands.entries()].sort((a, b) => a[0].localeCompare(b[0])).forEach(([cmd, groups]) => {
                    output += `${cmd}\n`;
                    groups.forEach((group, idx) => {
                        if (group.originalCommand !== normalizeCommand(group.originalCommand)) {
                            output += `${group.originalCommand}\n`;
                        }
                        output += group.responses.join('\n');
                        if (idx < groups.length - 1) {
                            output += '\n\n';
                        }
                    });
                    output += '\n\n';
                });
            }
            
            document.getElementById("outputLog").value = output.trim();
        }
    </script>
</body>
</html>